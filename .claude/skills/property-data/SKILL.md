---
name: property-data
description: Load, query, update, and validate property data from CSV listings and JSON enrichment files. Use for any property data access patterns, CRUD operations on enrichment_data.json, validation with Pydantic schemas, or property lookups by address.
allowed-tools: Read, Write, Bash(python:*), Grep
---

# Property Data Management Skill

Expert at managing property data for the PHX houses analysis project, including data loading, querying, updating, and validation through a comprehensive Pydantic-based validation layer.

## Table of Contents

1. [Data Sources](#data-sources)
2. [Schema Definitions](#schema-definitions)
3. [Validation Layer](#validation-layer)
4. [Data Normalization](#data-normalization)
5. [Data Operations](#data-operations)
6. [Best Practices](#best-practices)

---

## Data Sources

| File | Type | Purpose |
|------|------|---------|
| `data/phx_homes.csv` | CSV | Master listing data (read-only source) |
| `data/enrichment_data.json` | JSON | Enriched property data (read/write) |
| `data/phx_homes_ranked.csv` | CSV | Scored output (generated by analyze.py) |

---

## Schema Definitions

### CSV Schema (phx_homes.csv)

```
street, city, state, zip, price, price_num, beds, baths, sqft, price_per_sqft, full_address
```

### Enrichment JSON Schema

```json
{
  "full_address": "string (primary key)",
  "lot_sqft": "int|null",
  "year_built": "int|null",
  "garage_spaces": "int|null",
  "sewer_type": "city|septic|unknown|null",
  "tax_annual": "int|null",
  "hoa_fee": "int|null (0 = no HOA)",
  "commute_minutes": "int|null",
  "school_district": "string|null",
  "school_rating": "float 1-10|null",
  "orientation": "north|south|east|west|ne|nw|se|sw|null",
  "distance_to_grocery_miles": "float|null",
  "distance_to_highway_miles": "float|null",
  "solar_status": "owned|leased|none|null",
  "solar_lease_monthly": "int|null",
  "has_pool": "bool|null",
  "pool_equipment_age": "int|null",
  "roof_age": "int|null",
  "hvac_age": "int|null",
  "safety_neighborhood_score": "int 1-10|null",
  "distance_to_park_miles": "float|null",
  "parks_walkability_score": "int 1-10|null"
}
```

---

## Validation Layer

The validation module (`src/phx_home_analysis/validation/`) provides Pydantic-based schema validation, data normalization, and type inference for property data.

### Module Location

```
src/phx_home_analysis/validation/
    __init__.py       # Public exports
    schemas.py        # Pydantic model definitions
    validators.py     # PropertyValidator and ValidationResult
    normalizer.py     # Address normalization and type inference
```

### Quick Start

```python
from src.phx_home_analysis.validation import (
    PropertyValidator,
    ValidationResult,
    PropertySchema,
    normalize_address,
)

# Validate a property dictionary
validator = PropertyValidator()
result = validator.validate({
    "address": "123 W Main St, Phoenix, AZ 85001",
    "beds": 4,
    "baths": 2.5,
    "sqft": 2000,
    "price": 450000,
})

if result.is_valid:
    print("Valid property!")
    print(result.normalized_data)
else:
    print("Validation failed:")
    for error in result.error_messages():
        print(f"  - {error}")
```

### Validation Rules Reference

| Field | Type | Constraint | Notes |
|-------|------|------------|-------|
| `address` | str | min 5 chars, must contain digit | Required |
| `beds` | int | 1-20 | Required |
| `baths` | float | 0.5-20, 0.5 increments | Required |
| `sqft` | int | 100-100,000 | Required |
| `price` | int | >= 0 | Required |
| `lot_sqft` | int | 0-500,000 | Optional |
| `year_built` | int | 1800-current year | Cannot be future |
| `hoa_fee` | float | >= 0 | None = unknown, 0 = no HOA |
| `garage_spaces` | int | 0-10 | Optional |
| `has_pool` | bool | true/false | Optional |
| `pool_equipment_age` | int | 0-50 | Requires `has_pool=True` |
| `roof_age` | int | 0-100 | Optional |
| `hvac_age` | int | 0-50 | Optional |
| `sewer_type` | enum | city/septic/unknown | Optional |
| `solar_status` | enum | owned/leased/none/unknown | Optional |
| `orientation` | enum | north/south/east/west/ne/nw/se/sw/unknown | Optional |

### Pydantic Schemas

#### PropertySchema

Core property validation with required listing fields:

```python
from src.phx_home_analysis.validation.schemas import PropertySchema

# Validates and provides type coercion
property = PropertySchema(
    address="123 W Main St, Phoenix, AZ 85001",
    beds=4,
    baths=2.5,
    sqft=2000,
    price=450000,
    lot_sqft=8500,
    year_built=2005,
    has_pool=True,
    pool_equipment_age=5,
)

# Access validated data
print(property.model_dump())
```

#### EnrichmentDataSchema

Validates enrichment data with scoring fields:

```python
from src.phx_home_analysis.validation.schemas import EnrichmentDataSchema

enrichment = EnrichmentDataSchema(
    full_address="123 W Main St, Phoenix, AZ 85001",
    school_rating=7.5,
    safety_score=8.0,
    kitchen_layout_score=7.0,
    orientation="north",
    solar_status="owned",
)
```

#### KillSwitchCriteriaSchema

Validates properties against buyer kill-switch requirements:

```python
from src.phx_home_analysis.validation.schemas import KillSwitchCriteriaSchema

# This will raise ValidationError if criteria fail
try:
    criteria = KillSwitchCriteriaSchema(
        beds=4,           # min 4
        baths=2.0,        # min 2
        lot_sqft=8500,    # 7,000-15,000
        garage_spaces=2,  # min 2
        hoa_fee=0,        # must be 0 or None
        sewer_type="city",# must be city
        year_built=2005,  # < 2024
    )
    print("Property passes kill-switch criteria!")
except ValidationError as e:
    print(f"Kill-switch failed: {e}")
```

### PropertyValidator Class

The main validation interface with multiple validation methods:

```python
from src.phx_home_analysis.validation import PropertyValidator, ValidationResult

validator = PropertyValidator(normalize=True)  # Enable auto-normalization

# Validate core property data
result = validator.validate(property_dict)

# Validate enrichment data
result = validator.validate_enrichment(enrichment_dict)

# Validate against kill-switch criteria
result = validator.validate_kill_switch(property_dict)
```

### ValidationResult Object

Container for validation results with helper methods:

```python
result = validator.validate(data)

# Check validity
if result.is_valid:
    # Access normalized data
    clean_data = result.normalized_data
else:
    # Get all error messages as strings
    errors = result.error_messages()
    # ["beds: Input should be greater than or equal to 1"]

    # Get just the first error
    first = result.first_error()

    # Access raw Pydantic error dicts
    raw_errors = result.errors
    # [{"loc": ("beds",), "msg": "...", "type": "..."}]

# Check for warnings (non-fatal issues)
if result.warnings:
    print(f"Warnings: {result.warnings}")
```

### Batch Validation

Validate multiple records with aggregate statistics:

```python
from src.phx_home_analysis.validation.validators import BatchValidator

batch_validator = BatchValidator()

# Validate batch and get statistics
results, summary = batch_validator.validate_batch(property_records)

print(f"Valid: {summary['valid']}/{summary['total']}")
print(f"Success rate: {summary['valid_percent']:.1f}%")
print(f"Error types: {summary['error_types']}")

# Filter to only valid records
valid_records = batch_validator.filter_valid(property_records)
```

### Convenience Functions

Quick validation without instantiating a validator:

```python
from src.phx_home_analysis.validation.validators import (
    validate_property,
    validate_enrichment,
)

# Quick property validation
result = validate_property({"address": "123 Main", "beds": 4, ...})

# Quick enrichment validation
result = validate_enrichment({"full_address": "123 Main", "school_rating": 7.5})
```

---

## Data Normalization

The normalizer module provides utilities for standardizing data before validation.

### Address Normalization

```python
from src.phx_home_analysis.validation.normalizer import normalize_address

normalized = normalize_address("123 W Main St")
# Returns: "123 west main street"

normalized = normalize_address("456 N Oak Ave, Phoenix, AZ 85001")
# Returns: "456 north oak avenue, phoenix, az 85001"
```

**Transformations applied:**
- Converts to lowercase
- Expands direction abbreviations (N -> north, W -> west, etc.)
- Expands street type abbreviations (St -> street, Ave -> avenue, etc.)
- Removes extra whitespace

### Type Inference

```python
from src.phx_home_analysis.validation.normalizer import infer_type

infer_type("42")       # Returns: 42 (int)
infer_type("3.14")     # Returns: 3.14 (float)
infer_type("true")     # Returns: True (bool)
infer_type("hello")    # Returns: "hello" (str)
infer_type("")         # Returns: None
infer_type("n/a")      # Returns: None
```

### Field-Specific Normalizers

```python
from src.phx_home_analysis.validation.normalizer import (
    normalize_sewer_type,
    normalize_orientation,
    normalize_solar_status,
    clean_price,
    normalize_boolean,
)

# Sewer type normalization
normalize_sewer_type("municipal sewer")  # Returns: "city"
normalize_sewer_type("septic tank")      # Returns: "septic"

# Orientation normalization
normalize_orientation("N")               # Returns: "north"
normalize_orientation("north-west")      # Returns: "northwest"

# Solar status normalization
normalize_solar_status("PPA")            # Returns: "leased"
normalize_solar_status("purchased")      # Returns: "owned"

# Price cleaning
clean_price("$475,000")                  # Returns: 475000
clean_price("475k")                      # Returns: 475000

# Boolean normalization
normalize_boolean("yes")                 # Returns: True
normalize_boolean("0")                   # Returns: False
```

---

## Data Operations

### Load All Properties

```python
import json
import csv

# Load listings
with open("data/phx_homes.csv") as f:
    listings = list(csv.DictReader(f))

# Load enrichment
with open("data/enrichment_data.json") as f:
    enrichment = {p["full_address"]: p for p in json.load(f)}

# Merge
for listing in listings:
    addr = listing["full_address"]
    listing.update(enrichment.get(addr, {}))
```

### Load and Validate All Properties

```python
from src.phx_home_analysis.validation import PropertyValidator
from src.phx_home_analysis.validation.validators import BatchValidator
import json
import csv

# Load data
with open("data/phx_homes.csv") as f:
    listings = list(csv.DictReader(f))

# Validate batch
batch_validator = BatchValidator()
results, summary = batch_validator.validate_batch(listings)

print(f"Loaded {summary['total']} properties")
print(f"Valid: {summary['valid']} ({summary['valid_percent']:.1f}%)")

# Get only valid, normalized records
valid_properties = batch_validator.filter_valid(listings)
```

### Query Single Property

```python
def get_property(address: str) -> dict | None:
    """Get property by address (case-insensitive match)."""
    enrichment = json.load(open("data/enrichment_data.json"))
    addr_lower = address.lower()
    for prop in enrichment:
        if prop["full_address"].lower() == addr_lower:
            return prop
    return None
```

### Query and Validate Single Property

```python
from src.phx_home_analysis.validation import PropertyValidator

def get_validated_property(address: str) -> dict | None:
    """Get and validate property by address."""
    enrichment = json.load(open("data/enrichment_data.json"))
    addr_lower = address.lower()

    validator = PropertyValidator()
    for prop in enrichment:
        if prop["full_address"].lower() == addr_lower:
            result = validator.validate(prop)
            if result.is_valid:
                return result.normalized_data
            else:
                print(f"Warning: Property has validation errors: {result.error_messages()}")
                return prop  # Return raw data with warning
    return None
```

### Update Property Fields

```python
def update_property(address: str, updates: dict) -> bool:
    """Update specific fields for a property (atomic write)."""
    enrichment = json.load(open("data/enrichment_data.json"))

    for prop in enrichment:
        if prop["full_address"] == address:
            prop.update(updates)

            # Atomic write
            temp = "data/enrichment_data.json.tmp"
            with open(temp, "w") as f:
                json.dump(enrichment, f, indent=2)
            os.replace(temp, "data/enrichment_data.json")
            return True
    return False
```

### Update with Validation

```python
from src.phx_home_analysis.validation import PropertyValidator

def update_property_validated(address: str, updates: dict) -> tuple[bool, list[str]]:
    """Update property fields with validation.

    Returns:
        Tuple of (success, error_messages)
    """
    enrichment = json.load(open("data/enrichment_data.json"))
    validator = PropertyValidator()

    for prop in enrichment:
        if prop["full_address"] == address:
            # Merge updates
            merged = {**prop, **updates}

            # Validate merged data
            result = validator.validate_enrichment(merged)
            if not result.is_valid:
                return False, result.error_messages()

            # Apply validated/normalized data
            prop.update(result.normalized_data)

            # Atomic write
            temp = "data/enrichment_data.json.tmp"
            with open(temp, "w") as f:
                json.dump(enrichment, f, indent=2)
            os.replace(temp, "data/enrichment_data.json")
            return True, []

    return False, ["Property not found"]
```

### Count Properties by Field

```python
def count_properties_with_field(field: str) -> tuple[int, int]:
    """Count (populated, total) properties for a field."""
    enrichment = json.load(open("data/enrichment_data.json"))
    populated = sum(1 for p in enrichment if p.get(field) is not None)
    return populated, len(enrichment)
```

### Property Hash Calculation

```python
import hashlib

def property_hash(address: str) -> str:
    """Generate 8-char hash for property folder names."""
    return hashlib.md5(address.lower().encode()).hexdigest()[:8]
```

---

## Best Practices

### Data Integrity

1. **Always use atomic writes** - Write to .tmp then rename
2. **Preserve existing data** - Merge, don't overwrite entire objects
3. **Normalize addresses** - Use `full_address` as canonical key
4. **Handle nulls** - Distinguish between null (unknown) and 0 (confirmed zero)
5. **Track data source** - Add `_source` suffix fields when relevant

### Validation Guidelines

1. **Validate on input** - Validate data when loading from external sources
2. **Use appropriate schema** - PropertySchema for listings, EnrichmentDataSchema for research data
3. **Check kill-switch early** - Use `validate_kill_switch()` to filter non-qualifying properties
4. **Handle validation errors** - Always check `result.is_valid` before using data
5. **Log warnings** - Track `result.warnings` for data quality monitoring

### Cross-Field Validation

The validation layer enforces these business rules automatically:

1. **pool_equipment_age requires has_pool=True** - Cannot have pool age without a pool
2. **year_built cannot be future** - Validates against current year
3. **baths must be 0.5 increments** - Enforces half-bath convention
4. **address must contain a number** - Basic street address validation

### Error Handling Pattern

```python
from src.phx_home_analysis.validation import PropertyValidator

def process_property(data: dict) -> dict | None:
    """Process property with proper error handling."""
    validator = PropertyValidator()
    result = validator.validate(data)

    if not result.is_valid:
        address = data.get("address", "unknown")
        errors = result.error_messages()
        print(f"Validation failed for {address}:")
        for error in errors:
            print(f"  - {error}")
        return None

    if result.warnings:
        print(f"Warnings: {result.warnings}")

    return result.normalized_data
```

### Migration Guide

If you have existing code that doesn't use validation:

```python
# Before (no validation)
data = {"beds": "4", "baths": "2.5", "price": "$450,000"}
process(data)  # May fail on type errors

# After (with validation)
from src.phx_home_analysis.validation import validate_property

result = validate_property(data)
if result.is_valid:
    process(result.normalized_data)  # Properly typed data
else:
    handle_errors(result.error_messages())
```

---

## Enum Reference

### SewerTypeSchema

```python
from src.phx_home_analysis.validation import SewerTypeSchema

SewerTypeSchema.CITY      # "city"
SewerTypeSchema.SEPTIC    # "septic"
SewerTypeSchema.UNKNOWN   # "unknown"
```

### SolarStatusSchema

```python
from src.phx_home_analysis.validation import SolarStatusSchema

SolarStatusSchema.OWNED    # "owned"
SolarStatusSchema.LEASED   # "leased"
SolarStatusSchema.NONE     # "none"
SolarStatusSchema.UNKNOWN  # "unknown"
```

### OrientationSchema

```python
from src.phx_home_analysis.validation import OrientationSchema

OrientationSchema.N   # "north"
OrientationSchema.S   # "south"
OrientationSchema.E   # "east"
OrientationSchema.W   # "west"
OrientationSchema.NE  # "northeast"
OrientationSchema.NW  # "northwest"
OrientationSchema.SE  # "southeast"
OrientationSchema.SW  # "southwest"
OrientationSchema.UNKNOWN  # "unknown"
```

---

## Related Skills

- **kill-switch**: Uses validation to check buyer criteria
- **scoring**: Validates scores are within expected ranges
- **county-assessor**: Validates data from Maricopa County API
